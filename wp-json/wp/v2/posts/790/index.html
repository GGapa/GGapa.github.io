{"id":790,"date":"2023-11-01T13:24:06","date_gmt":"2023-11-01T05:24:06","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=790"},"modified":"2023-11-11T23:04:48","modified_gmt":"2023-11-11T15:04:48","slug":"2023-10-30-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e9%87%8e%e4%ba%ba%e8%bf%87%e6%b2%b3","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/11\/01\/2023-10-30-%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%e9%87%8e%e4%ba%ba%e8%bf%87%e6%b2%b3\/","title":{"rendered":"2023.10.30 学习笔记(野人过河)"},"content":{"rendered":"<h4>题目描述\n</h4>
<p>有三个野人三个道士，他们在何的右岸，现有一艘只能容纳两个人的小船，因为野人比较野蛮，如果河一侧野人的数量大于道士的数量，野人就会攻击道士，问如何安全的过河。输出任意一种方案。\n
<h4>问题分析\n</h4>
<p>这道题目可以通过搜索来实现，广搜和深搜均可，在这里为了锻炼使用广搜的代码能力，笔者决定用广搜来解答这道题目。\n
<p>为了进行广搜我们需要创建一个三元组$(x, (y, z))$，分别代表着河右岸道士的人数，野人的人数，船在左侧还是在右侧，其中记 $1$ 为船在右侧，记 $0$ 为船在左侧。就可以通过两种情况进行分类讨论。\n
<p>当 $z=1$ 时，有以下几种情况：\n
<ul>\n<li>两个道士到达左岸\n</li>
<li>一个道士一个野人到达左岸\n</li>
<li>一个道士到达左岸\n</li>
<li>一个野人到达左岸\n</li>
<li>两个野人到达左岸。\n\n<p>当 $z=2$ 时的情况与上文相近，只是从左岸到达右岸。\n
<p>分析完毕后，我们可以得到以下的转移数组：\n
<pre><code class='\"language-cpp\"'>int dx[10] =  {-1, -1, -2, 0, 0, 1, 1, 2, 0, 0};\nint dy[10] =  {-1, 0, 0, -1, -2, 1, 0, 0, 2, 1};\n<p>其中 $0-5$ 号元素代表着船在右岸的情况，剩余的元素代表船在左岸的情况。在转移的时候要判断状态的合法性，切记如果某一时刻道士的人数为 $0$ 野人是无法攻击道士的。\n
<p>因为题目要求需要输出合法的方案，故在广搜的时候我们需要通过链表记录一下这个状态的上一个转台，最后从最后的状态开始，倒序输出。倒序输出可以通过栈来实现，这里不做过多的讲解。\n
<h4>参考代码\n<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\n\nint dx[10] =  {-1, -1, -2, 0, 0, 1, 1, 2, 0, 0};\nint dy[10] =  {-1, 0, 0, -1, -2, 1, 0, 0, 2, 1};\nint used[5][5][5];\nint n = 3;\nmap&lt;pair&lt;int, pair&lt;int, int&gt;&gt;, pair&lt;int, pair&lt;int, int&gt;&gt;&gt; ans;\n\nvoid out() {\n    stack&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; tmp;\n    pair&lt;int, pair&lt;int, int&gt;&gt; it =  make_pair(0, make_pair(0, 0)), ed = make_pair(3, make_pair(3, 1));\n    do{\n        tmp.push(it);\n        it = ans[it];\n    }while(it != ed);\n\/\/  cout &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second.first &lt;&lt; &quot; &quot; &lt;&lt; it.second.second &lt;&lt; &quot;\\n&quot;;\n    tmp.push(it);\n    while(!tmp.empty()) cout &lt;&lt; tmp.top().first &lt;&lt; &quot; &quot; &lt;&lt; tmp.top().second.first &lt;&lt; &quot; &quot; &lt;&lt; tmp.top().second.second &lt;&lt; &quot;\\n&quot;, tmp.pop();\n    exit(0);\n}\n\nvoid bfs() {\n    queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; q;\n\n    q.push(make_pair(3, make_pair(3, 1)));\n    while(!q.empty()) {\n        if(q.front() == make_pair(0, make_pair(0, 0)))  {\n            out();\n            return ;\n        }\n        int x = q.front().first, y = q.front().second.first; \n        if(q.front().second.second) {\n            for(int i = 0; i &lt; 5; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if((nx &lt; ny &amp;&amp; nx != 0) || (n - nx &lt; n - ny &amp;&amp; nx != 3)|| used[nx][ny][0] != 0|| nx &lt; 0 || ny &lt; 0|| nx &gt; n || ny &gt; n) continue;\n                used[nx][ny][0] = 1;\n                q.push(make_pair(nx, make_pair(ny, 0)));\n                ans[make_pair(nx, make_pair(ny, 0))] = make_pair(x, make_pair(y, 1));\n            }\n        }\n        else {\n            for(int i = 5; i &lt; 10; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if((nx &lt; ny &amp;&amp; nx != 0) || (n - nx &lt; n - ny &amp;&amp; nx != 3)||used[nx][ny][1] != 0|| nx &lt; 0 || ny &lt; 0|| nx &gt; n || ny &gt; n) continue;\n                used[nx][ny][1] = 1;\n                q.push(make_pair(nx, make_pair(ny, 1)));\n                ans[make_pair(nx, make_pair(ny, 1))] = make_pair(x, make_pair(y, 0));\n            }\n        }\n        q.pop();\n    }\n} \n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\/\/  freopen(&quot;AKIOI.in&quot;, &quot;r&quot;, stdin);\n\/\/  freopen(&quot;AKIOI.out&quot;, &quot;w&quot;, stdout);\n    bfs();\n    return 0;\n}\n\n","protected":false},"excerpt":{"rendered":"<p>题目描述 有三个野人三个道士，他们在何的右岸，现有一艘只能容纳两个人的小船，因为野人比较野蛮，如果河一侧野人的 [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[30],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/790"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=790"}],"version-history":[{"count":5,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/790\/revisions"}],"predecessor-version":[{"id":795,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/790\/revisions\/795"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=790"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=790"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=790"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre>
</h4></code></pre>
</li>
</ul>