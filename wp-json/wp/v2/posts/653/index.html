{"id":653,"date":"2023-10-03T17:51:46","date_gmt":"2023-10-03T09:51:46","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=653"},"modified":"2023-10-15T00:18:13","modified_gmt":"2023-10-14T16:18:13","slug":"usaco17jan-hoof-paper-scissor-g-%e7%9a%84%e4%b8%a4%e7%a7%8d%e8%a7%a3%e6%b3%95%e4%bb%a5%e5%8f%8a%e5%9c%a8%e6%92%b0%e5%86%99c%e4%bb%a3%e7%a0%81%e6%97%b6%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/10\/03\/usaco17jan-hoof-paper-scissor-g-%e7%9a%84%e4%b8%a4%e7%a7%8d%e8%a7%a3%e6%b3%95%e4%bb%a5%e5%8f%8a%e5%9c%a8%e6%92%b0%e5%86%99c%e4%bb%a3%e7%a0%81%e6%97%b6%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b\/","title":{"rendered":"[USACO17JAN] Hoof, Paper, Scissor G 的两种解法以及在撰写C++代码时的注意事项"},"content":{"rendered":"<p><a href="\"https:\/\/www.luogu.com.cn\/problem\/P3609\"">题目传送门\n<p>在编写代码的时候多写写注释！！<br>\n多写十秒钟注释少调试十分钟程序！！\n
<h1>记忆化搜索\n<pre><code class='\"language-cpp\"'>\/*\nproblem:[USACO17JAN] Hoof, Paper, Scissor G\nURL:https:\/\/www.luogu.com.cn\/problem\/P3609\ntime:2023-10-03\n记忆化搜索\n*\/\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int maxn = 1e5 + 5;\n\nint n, k;\nint a[maxn], F[maxn][22][3]; \/\/f[i][j][k] 前 i 轮，变换了 j 次，最后一次出的 k\n\/\/ 还有一个小技巧，数组名用大写，为了方便需要多次操作的数组元素用小写字母代替\n\nint dfs(int x, int b, int w) { \/\/ 第 x 轮，还可以变换 b 次，上一轮出的 w\n    if(!x || b &lt; 0) return 0; \/\/边界条件判断\n    int &amp;f = F[x][b][w], p = -1; \n    if(f) return f; \n    for(int i = 0; i &lt;= 2; i++) \n        p = max(p, dfs((x - 1), b - (i != w), i)); \/\/向前搜索，计算需不需要消耗次数\n    return f = p + (w == a[x]); \/\/返回能否胜利，并且赋值\n}\n\nint main() {\n    ios::sync_with_stdio(0); \/\/ IO 优化\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; k;\n    string s = &quot;PHS&quot;; \/\/将字符转化为 int，方便操作\n    char c;\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; c;\n        a[i] = s.find(c); \/\/字符串 s 中的字符很少，时间复杂度可以看作常数\n    }\n    for(int j = 0; j &lt;= 2; j++) ans = max(ans, dfs(n, k, j));\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; \/\/建议不要使用 endl 容易出锅\n    return 0; \/\/华丽收场\n}\n\/*\n编程语言\nC++14 (GCC 9)\n代码长度\n1.05KB\n用时\n415ms\n内存\n32.14MB\n*\/\n<h1>动态规划 + 滚动数组\n<pre><code class='\"language-cpp\"'>\/*\nproblem:[USACO17JAN] Hoof, Paper, Scissor G\nURL:https:\/\/www.luogu.com.cn\/problem\/P3609\ndate:2023-10-03\n动态规划+滚动数组\n*\/\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint n, k;\nint D[2][24][5]; \/\/ D[i][j][k] i 作为滚动数组来使用，j 代表换了多少次手势，k 代表上一次出的手势是什么\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; k;\n    char ch;\n    string s = &quot;HPS&quot;; \/\/记录一下，方便 char 转换为 int \n    for(int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; ch; \/\/ 0 克制 1，1 克制 2，2 克制 0\n        int ci = i % 2, i1 = ci ^ 1;\/\/ci 代表的是数组 D 使用到的层数，而 i1 代表的是上一层\n        for(int j = 0; j &lt;= k; j++) {\n            for(int q = 0; q &lt;= 2; q++) {\n                int q1 = (q + 1) % 3, q2 = (q + 2) % 3, &amp;d = D[ci][j][q];\n                \/\/上面那一行 q q1 q2 代表的是 其他可能会出的手势\n                if (q1 == (int)s.find(ch))\n                    d = max({D[i1][j][q], D[i1][j + 1][q1], D[i1][j + 1][q2]}) + 1; \/\/不要傻乎乎的嵌套 max， 用一个 {} 就足够了\n                else \/\/如果输了\n                    d = D[i1][j][q];\n            }\n        }\n    }\n    int ci = n % 2; \/\/确定现在是哪一层\n    cout &lt;&lt; max({D[ci][0][0], D[ci][0][1], D[ci][0][2]}); \/\/ max 要用 algorithm 头文件\n    return 0; \/\/完美收场\n}\n\/*\n编程语言\nC++14 (GCC 9)\n代码长度\n1.16KB\n用时\n266ms\n内存\n880.00KB\n*\/\n<h1>总结\n</h1>
<p>可以很明显的看出来，方法二的内存是远小于方法一的。<br>\n在大型考试的时候开很大的内存容易影响老爷机的心情，导致 TLE<br>\n所以说如果感觉空间会很大而且担心超时的情况下还是选择滚动数组吧qaq\n","protected":false},"excerpt":{"rendered":"
<p>题目传送门 在编写代码的时候多写写注释！！ 多写十秒钟注释少调试十分钟程序！！ 记忆化搜索 \/* proble [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/653"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=653"}],"version-history":[{"count":1,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/653\/revisions"}],"predecessor-version":[{"id":654,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/653\/revisions\/654"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=653"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=653"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=653"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre>
</h1></code></pre>
</h1></a>