{"id":1118,"date":"2024-02-18T20:21:09","date_gmt":"2024-02-18T12:21:09","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=1118"},"modified":"2024-02-18T20:21:09","modified_gmt":"2024-02-18T12:21:09","slug":"lcs","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2024\/02\/18\/lcs\/","title":{"rendered":"LCS"},"content":{"rendered":"<p>LCS——经典的 DP 问题，给定两个长度为 $n$ 的排列，试问二者的最长公共子序列。这是经典的区间 DP 问题，\n
<p>首先考虑朴素做法，定义 $dp[i][j]$ 来表示第一个串的前 $i$ 位，第二个串的前 $j$ 的 $LCS$ 长度，易得状态转移方程：\n
<ul>\n<li>\n<p>如果两个序列没有新的相同元素\n
<p>$dp[i][j] = \\max(dp[i-1][j],dp[i][j-1])$\n\n
</li>
<li>\n<p>否则\n
<p>$dp[i][j]= \\max(dp[i][j],dp[i-1][j-1]+1)$\n
<p>时间复杂度 $O(n^2)$ 。\n\n\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\nusing namespace std;\nconst int maxn = 1e4 + 5;\n\nint a[maxn], b[maxn], f[maxn][maxn];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin &gt;&gt; n;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i];\n    for(int i = 1; i &lt;= n; i++) {\n        for(int j = 1; j &lt;= n; j++) {\n            f[i][j] = max(f[i-1][j], f[i][j-1]);\n            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);\n        }\n    }\n    cout &lt;&lt; f[n][n] &lt;&lt; &quot;\\n&quot;;\n    return 0;\n}\n<p>由于时间复杂度中惨了一份平方，所以说在大多数题目下都不适用，此时考虑进行优化。试着将 $LCS$ 问题转换成 $LIS$ 问题，因为我们两个排列，而排列中的所有元素均不相同，因此可以根据其出现的位置，把元素重新编号。\n
<p>解释：\n
<blockquote>\n<p>因为<strong>最长公共子序列是按位向后比对的，所以a序列每个元素在b序列中的位置如果递增，就说明b中的这个数在a中的这个数整体位置偏后。\n<p>—— 离散小波变换\n\n
<p>时间复杂度 $O(n \\log n)$。\n
<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\n#define rep(i, a, b) for (int i = (a), stOwxc = (b); i &lt;= stOwxc; i++)\n#define per(i, a, b) for (int i = (a), stOwxc = (b); i &gt;= stOwxc; i--)\nusing namespace std;\ntypedef long long ll;\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, x;\n    cin &gt;&gt; n;\n    unordered_map&lt;int, int&gt; mp;\n    rep(i, 1, n) cin &gt;&gt; x, mp[x] = i;\n    vector&lt;int&gt; L;\n    rep(i, 1, n) {\n        cin &gt;&gt; x;\n        if (!mp.count(x))\n            continue;\n        int s = mp[x];\n        auto it = lower_bound(L.begin(), L.end(), s);\n        if (it == L.end())\n            L.push_back(s);\n        else\n            *it = s;\n    }\n    cout &lt;&lt; L.size() &lt;&lt; &#039;\\n&#039;;\n    return 0;\n}\n<p>注意：\n
<ul>\n<li><code>map 的常数稍大，可以考虑 <code>unordered_map 来解决问题，在洛谷模板题中，后者比前者快了 $50\\%$ 。\n\n","protected":false},"excerpt":{"rendered":"<p>LCS——经典的 DP 问题，给定两个长度为 $n$ 的排列，试问二者的最长公共子序列。这是经典的区间 DP  [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[31],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/1118"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=1118"}],"version-history":[{"count":1,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/1118\/revisions"}],"predecessor-version":[{"id":1119,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/1118\/revisions\/1119"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=1118"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=1118"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=1118"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></code></li>
</ul></code></pre></strong>
</blockquote></code></pre>
</li>
</ul>