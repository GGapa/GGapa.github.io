{"id":667,"date":"2023-10-04T19:41:53","date_gmt":"2023-10-04T11:41:53","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=667"},"modified":"2023-11-09T21:08:19","modified_gmt":"2023-11-09T13:08:19","slug":"dfs-%e5%ba%8f%e5%9c%a8%e7%a5%96%e5%85%88%e9%97%ae%e9%a2%98%e7%9a%84%e4%bd%bf%e7%94%a8","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/10\/04\/dfs-%e5%ba%8f%e5%9c%a8%e7%a5%96%e5%85%88%e9%97%ae%e9%a2%98%e7%9a%84%e4%bd%bf%e7%94%a8\/","title":{"rendered":"DFS 序在祖先问题的使用"},"content":{"rendered":"<p><a href="\"https:\/\/loj.ac\/p\/10135\"">祖孙询问\n<p>此问题可以用 LCA 来解决，但是 LCA 的码量大，而且可能容易写挂，<del>尤其是像我这种蒟蒻\n<p>如果卡时间的话有可能倍增\/重链剖分 LCA 都要挂掉，这时候就是 DFS 序发挥作用的时候了。\n
<hr>\n<p>拿一个计数器。在遍历到每一个节点的时候，我们在进入它的时候记录一下，在离开它的时候也记录一下，在记录完成后就得到了一个树的 DFS 序\n
<p>代码如下：\n
<pre><code class='\"language-cpp\"'>\/*\nLOJ10135\nhttps:\/\/loj.ac\/p\/10135\n*\/\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int maxn = 4e4 + 5;\n\nint n, m, root;\nvector&lt;int&gt; G[maxn];\nint ti;\nint in[maxn], out[maxn];\n\nvoid dfs(int x) {\n    if(in[x] != 0) return;\n    in[x] = ++ti;\n    for(int to : G[x]) dfs(to);\n    out[x] = ++ti;\n}\n\nint ask(int x, int y) {\n\n    return in[x] &lt; in[y] &amp;&amp; in[y] &lt; out[y] &amp;&amp; out[y] &lt; out[x];\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for(int i = 1, u, v; i &lt;= n; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        if(v == -1) {\n            root = u;\n            continue;\n        }\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(root);\n    cin &gt;&gt; m;\n    for(int i = 1, u, v; i &lt;= m; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        if(ask(u, v)) cout &lt;&lt; 1 &lt;&lt; &quot;\\n&quot;;\n        else if(ask(v, u)) cout &lt;&lt; 2 &lt;&lt; &quot;\\n&quot;;\n        else cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n} \n\n\/\/106ms\n<p>与倍增 LCA 相比，快了些许\n
<pre><code class='\"language-cpp\"'>祖孙询问(LOJ10135)\nhttps:\/\/vjudge.csgrandeur.cn\/contest\/584212#problem\/D\n*\/\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int maxn = 4e4 + 5;\nconst int maxk = 20; \n\nint n, root, m;\nvector&lt;int&gt; G[maxn];\n\nint fa[maxk][maxn];\nint depth[maxn];\n\nvoid dfs(int x, int f) {\n    fa[0][x] = f;\n    depth[x] = depth[f] + 1;\n    for (int i = 1; i &lt; maxk; i++) {\n        fa[i][x] = fa[i - 1][fa[i - 1][x]];\n    }\n    for (auto to : G[x]) {\n        if (to == f)\n            continue;\n        dfs(to, x);\n    }\n}\n\nint LCA(int x, int y) {\n    if (depth[x] &lt; depth[y])\n        swap(x, y);\n    for (int i = maxk - 1; i &gt;= 0; i--) {\n        if (depth[fa[i][x]] &gt;= depth[y])\n            x = fa[i][x];\n    }\n    if (x == y)\n        return x;\n    for (int i = maxk - 1; i &gt;= 0; i--) {\n        if (fa[i][x] != fa[i][y]) {\n            x = fa[i][x];\n            y = fa[i][y];\n        }\n    }\n    return fa[0][x];\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    for(int i = 1, u, v; i &lt;= n; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        if(v == -1) {root = u; continue;}\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    cin &gt;&gt; m;\n    int x, y;\n    dfs(root, 0);\n    while(m--) {\n        cin &gt;&gt; x &gt;&gt; y;\n        int lca = LCA(x, y);\n        if(lca == x) cout &lt;&lt; &quot;1\\n&quot;;\n        else if(lca == y) cout &lt;&lt; &quot;2\\n&quot;;\n        else cout &lt;&lt; &quot;0\\n&quot;;\n    }\n}\n\/\/130ms\n<p>因为在使用 DFS 序解决问题时，它的查询是常数时间复杂度，所以说要快很多。\n
<p>当然，DFS 序也可以用于LCA问题中，详见<a href="\"https:\/\/ggapa.github.io\/2023\/11\/09\/lca-%e9%97%ae%e9%a2%98%e7%9a%84%e4%b8%8d%e5%90%8c%e8%a7%a3%e6%b3%95\/\"">这篇文章。\n","protected":false},"excerpt":{"rendered":"<p>祖孙询问 此问题可以用 LCA 来解决，但是 LCA 的码量大，而且可能容易写挂，尤其是像我这种蒟蒻 如果卡时 [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/667"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=667"}],"version-history":[{"count":3,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/667\/revisions"}],"predecessor-version":[{"id":839,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/667\/revisions\/839"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=667"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=667"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=667"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</a></code></pre></code></pre></del></a>