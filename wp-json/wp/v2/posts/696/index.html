{"id":696,"date":"2023-10-15T19:53:15","date_gmt":"2023-10-15T11:53:15","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=696"},"modified":"2023-10-17T14:52:53","modified_gmt":"2023-10-17T06:52:53","slug":"%e3%80%90lgr-164-div-2%e3%80%91%e6%b4%9b%e8%b0%b7-csp-s-2023-%e6%a8%a1%e6%8b%9f%e8%b5%9b-%e3%80%8ckdoi%e3%80%8dround-6-s-%e8%b5%9b%e5%90%8e%e6%80%bb%e7%bb%93","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/10\/15\/%e3%80%90lgr-164-div-2%e3%80%91%e6%b4%9b%e8%b0%b7-csp-s-2023-%e6%a8%a1%e6%8b%9f%e8%b5%9b-%e3%80%8ckdoi%e3%80%8dround-6-s-%e8%b5%9b%e5%90%8e%e6%80%bb%e7%bb%93\/","title":{"rendered":"【LGR-164-Div.2】洛谷 CSP-S 2023 模拟赛 &#038;「KDOI」Round 6-S 赛后总结"},"content":{"rendered":"<p>
<div class="fancybox-wrapper lazyload-container-unload" data-fancybox="post-images" href="https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/m7zlu7e1.png">
<img class='\"lazyload' lazyload-style-1 src="\"data:image\/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"" decoding='\"async\"' data-original='\"https:\/\/cdn.luogu.com.cn\/upload\/image_hosting\/m7zlu7e1.png\"' alt='\"\"'>\n<h1>T1 60pts\n</h1>
<p>关于我考试时没有想出来，但是考完试回头看突然就想出来这件事情。<br>\n我当时候为什么会这样子？考试的时候看到第一题觉得很一般，没有多难。但我分析算法的时间复杂度的时候误分析成 $O(n)$ ，导致我充满信心的写完了“正解”之后测试大样例，结果发现我这个不是正解，我代码的时间复杂度是 $O(n^2)$ 的，我就开始找问题，发现有一些预处理可以省略，于是我就省略了，但是在考试的时候始终有一个问题困扰着我，如何处理 $a$数组？这个问题我冥思苦想，想了很久，但是我碰巧没有想出来对于每一个 $a$ 都可以进行递推求解。我就在想贪心等其他的事，知道最后和正解就差一个 $a$ 的递推了，我却选择跳过这道题目。提交了我最开始写的代码。<br>\n接着我就去看后面的题目了，直到考试结束后面的题目也没有看完。\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int maxn = 5e5 + 5;\n#define int long long\n\nint read() {\n    int f = 1, x = 0;\n    char c;\n    c = getchar();\n    while(!isdigit(c)) {\n        if(c == &#039;-&#039;) f = -1;\n        c = getchar();\n    }\n    while(isdigit(c)) {\n        x = x * 10 + (c - &#039;0&#039;);\n        c = getchar();\n    }\n    return x;\n}\n\nint n, m;\nint a[maxn], b[maxn], c[maxn], p[maxn];\nint q;\nint sumb[maxn], sumc[maxn], suma[maxn];\n\nvoid init() {\n    for(int i = 1; i &lt;= n; i++) sumc[i] = sumb[i] = suma[i] = 0;\n    for(int i = 1; i &lt;= m; i++) sumc[p[i]] = c[p[i]], sumb[p[i]] = -1 * b[p[i]];\n    for(int i = 1; i &lt;= n; i++) sumc[i] += sumc[i-1], sumb[i] += sumb[i-1] + b[i]; \/\/在p内的不用记录\n}\n\nsigned main() {\n    \/\/freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);\n    \/\/freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);\n    n = read();\n    for(int i = 1; i &lt;= n; i++) a[i] = read();\n    for(int i = 1; i &lt;= n; i++) b[i] = read();\n    for(int i = 1; i &lt;= n; i++) c[i] = read();\n    q = read();\n    while(q--) {\n        long long ans = 1e18;\n        m = read();\n        for(int i = 1; i &lt;= m; i++) p[i] = read();\n\n        init();\n\n        for(int i = n; i &gt;= 0; i--) {\n            \/\/cout &lt;&lt; sumc[i] &lt;&lt; &quot; &quot; &lt;&lt; sumb[n] - sumb[i] &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; &quot;\\n&quot;;\n            ans = min(sumc[i] + sumb[n] - sumb[i] + a[i], ans);\n        } \n\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n}\n<p>后来改的\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nconst int maxn = 5e5 + 5;\n#define int long long\n\nint read() {\n    int f = 1, x = 0;\n    char c;\n    c = getchar();\n    while(!isdigit(c)) {\n        if(c == &#039;-&#039;) f = -1;\n        c = getchar();\n    }\n    while(isdigit(c)) {\n        x = x * 10 + (c - &#039;0&#039;);\n        c = getchar();\n    }\n    return x;\n}\n\nint n, m;\nint a[maxn], b[maxn], c[maxn], p[maxn];\nint q;\nint sumb[maxn], sumc[maxn], suma[maxn], mina[maxn], pc[maxn], pb[maxn];\n\nsigned main() {\n    n = read();\n    for(int i = 1; i &lt;= n; i++) a[i] = read();\n    for(int i = 1; i &lt;= n; i++) b[i] = read(), sumb[i] = sumb[i-1] + b[i];\n    for(int i = 1; i &lt;= n; i++) c[i] = read();\n    for(int i = 1; i &lt;= n; i++) suma[i] = min(a[i], suma[i-1] + b[i]);\n    q = read();\n    while(q--) {\n        long long ans = sumb[n];\n        m = read();\n        for(int i = 1; i &lt;= m; i++) p[i] = read(), pc[i] = pc[i-1] + c[p[i]], ans -= b[p[i]];\n        for(int i = m; i &gt;= 1; i--) pb[i] = pb[i+1] + b[p[i]];\n        for(int i = 1; i &lt;= m; i++) {\n            ans = min(ans, suma[p[i]-1] + pc[i-1] + sumb[n] - sumb[p[i]-1] - pb[i]);\n        }\n         ans = min(ans, suma[n] + pc[m]);\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n        for(int i = 1;  i&lt;= m; i++) pb[i] = pc[i] = 0;\n    }\n    return 0;\n}\n<h1>T2 0pts\n</h1>
<p>考试的时候看了一眼这道题目，没思路，暴力打卦了。\n
<p>代码是不可以总司令，没啥好看的。\n
<h1>T3 40pts\n</h1>
<p>考试的时候看到这道题就开始打搜索，在考试快结束的时候打出来了。\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint T;\nint n;\nset&lt;vector&lt;int&gt; &gt; mp;\nstruct Step {\n    int i, j, k;\n};\nvector&lt;Step&gt; step;\nbool flag = false;\n\nvoid out() {\n    cout &lt;&lt; &quot;Huoyu\\n&quot;;\n    cout &lt;&lt; step.size() &lt;&lt; &quot;\\n&quot;;\n    for(auto i : step) {\n        cout &lt;&lt; i.i &lt;&lt; &quot; &quot; &lt;&lt; i.j &lt;&lt; &quot; &quot; &lt;&lt; i.k &lt;&lt; &quot;\\n&quot;;\n    }\n}\n\nvoid dfs(vector&lt;int&gt; x) {\n    if(flag) return;\n    if(x.size() == 1) {\n        flag = true;\n        out();\n        return;\n    }\n    if(mp.count(x) || x.size() &lt; 3) return;\n    mp.insert(x);\n    vector &lt;int&gt; tmp = x;\n    int len = x.size();\n    for(int i = 0; i &lt; len; i++) \n        for(int j = i + 1; j &lt; len; j++)\n            for(int k = j + 1; k &lt; len; k++) \n                if((x[i] ^ x[j] ^ x[k]) == 0) {\n                    step.push_back(Step{i+1, j+1, k+1});\n                    int s = 0;\n                    for(int q = i; q &lt;= k; q++) s ^= x[q];\n                    x.insert(x.begin() + i, s);\n                    x.erase(x.begin() + i + 1, x.begin() + k + 2);\n                    dfs(x);\n                    x = tmp;\n                    step.pop_back();\n                }\n}\n\nint main() {\n    cin &gt;&gt; T;\n    while(T--) {\n        cin &gt;&gt; n;\n        vector&lt;int&gt; a(n);\n        mp.clear();\n        step.clear();\n        flag = false;\n        for(auto &amp;i : a) cin &gt;&gt; i;\n        dfs(a);\n        if(!flag) cout &lt;&lt; &quot;Shuiniao\\n&quot;;\n    }\n    return 0;\n}\n<p>但是考完试的时候发现自己的这个效率写的太低下了，在考完试后尝试了许多优化的方法，其中运用<a href="\"https:\/\/oi-wiki.org\/search\/iterative\/\"">迭代加深搜索得到了 65pts, 但是我看他们得到了 75pts 目前正在探究之中。\n<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint T;\nint n;\nset&lt;vector&lt;int&gt; &gt; mp;\nstruct Step {\n    int i, j, k;\n};\nvector&lt;Step&gt; step;\nbool flag = false;\nint mdep = 1;\n\nvoid out() {\n    cout &lt;&lt; &quot;Huoyu\\n&quot;;\n    cout &lt;&lt; step.size() &lt;&lt; &quot;\\n&quot;;\n    for(auto i : step) {\n        cout &lt;&lt; i.i &lt;&lt; &quot; &quot; &lt;&lt; i.j &lt;&lt; &quot; &quot; &lt;&lt; i.k &lt;&lt; &quot;\\n&quot;;\n    }\n}\n\nvoid dfs(int it, vector&lt;int&gt; x) {\n    if(flag) return;\n    if(x.size() == 1) {\n        flag = true;\n        out();\n        return;\n    }\n    \/\/mp.insert(x);\n    if(it &gt; mdep) return ;\n    vector &lt;int&gt; tmp = x;\n    int len = x.size();\n    for(int i = 0; i &lt; len; i++) \n        for(int j = i + 1; j &lt; len; j++)\n            for(int k = j + 1; k &lt; len; k++) \n                if((x[i] ^ x[j] ^ x[k]) == 0) {\n                    step.push_back(Step{i+1, j+1, k+1});\n                    int s = 0;\n                    for(int q = i; q &lt;= k; q++) s ^= x[q];\n                    x.insert(x.begin() + i, s);\n                    x.erase(x.begin() + i + 1, x.begin() + k + 2);\n                    dfs(it + 1, x);\n                    x = tmp;\n                    step.pop_back();\n                }\n}\n\nint main() {\n    cin &gt;&gt; T;\n    while(T--) {\n        cin &gt;&gt; n;\n        vector&lt;int&gt; a(n);\n\n        step.clear();\n        flag = false;\n        mdep = 1;\n        for(auto &amp;i : a) cin &gt;&gt; i;\n        while(mdep++ &lt;= n) dfs(1, a);\n        if(!flag) cout &lt;&lt; &quot;Shuiniao\\n&quot;;\n    }\n    return 0;\n}\n\n<p>再后来看到讨论区里面的神犇发布了一个非常妙的方法（有可能是数据水，卡的数据），然后我试了一下就过了，目前正在请教他这个是怎么得出来的。\n
<pre><code class='\"language-cpp\"'>\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\nusing namespace std;\n\nint T;\nint n;\nset&lt;vector&lt;int&gt; &gt; mp;\nstruct Step {\n    int i, j, k;\n};\nvector&lt;Step&gt; step;\nbool flag = false;\nint mdep = 1;\n\nvoid out() {\n    cout &lt;&lt; &quot;Huoyu\\n&quot;;\n    cout &lt;&lt; step.size() &lt;&lt; &quot;\\n&quot;;\n    for(auto i : step) {\n        cout &lt;&lt; i.i &lt;&lt; &quot; &quot; &lt;&lt; i.j &lt;&lt; &quot; &quot; &lt;&lt; i.k &lt;&lt; &quot;\\n&quot;;\n    }\n}\n\nvoid dfs(int it, vector&lt;int&gt; x) {\n    if(flag) return;\n    if(x.size() == 1) {\n        flag = true;\n        out();\n        return;\n    }\n    \/\/mp.insert(x);\n    if(it &gt; mdep) return ;\n    vector &lt;int&gt; tmp = x;\n    int len = x.size();\n    for(int i = 0; i &lt;= (n &gt;= 400 ? 1 : 2); i++)  \/\/这里参考了一下洛谷讨论区里的思路 \n        for(int j = i + 1; j &lt; len; j++)\n            for(int k = j + 1; k &lt; len; k++) \n                if((x[i] ^ x[j] ^ x[k]) == 0) {\n                    step.push_back(Step{i+1, j+1, k+1});\n                    int s = 0;\n                    for(int q = i; q &lt;= k; q++) s ^= x[q];\n                    x.insert(x.begin() + i, s);\n                    x.erase(x.begin() + i + 1, x.begin() + k + 2);\n                    dfs(it + 1, x);\n                    x = tmp;\n                    step.pop_back();\n                }\n}\n\nint main() {\n    cin &gt;&gt; T;\n    while(T--) {\n        cin &gt;&gt; n;\n        vector&lt;int&gt; a(n);\n\n        step.clear();\n        flag = false;\n        mdep = 1;\n        for(auto &amp;i : a) cin &gt;&gt; i;\n        while(mdep++ &lt;= n) dfs(1, a);\n        if(!flag) cout &lt;&lt; &quot;Shuiniao\\n&quot;;\n    }\n    return 0;\n}\n\n<h1>T4 0pts\n</h1>
<p>不会做，暴力不会打，没时间。\n
<p>代码是不可以总司令，没啥好看的\n
<h1>总结\n</h1>
<p>考试是遇见了感觉自己会做的题目但是又没写出来，在考试快结束的时候一定要回顾再想一想\n","protected":false},"excerpt":{"rendered":"
<p>T1 60pts 关于我考试时没有想出来，但是考完试回头看突然就想出来这件事情。 我当时候为什么会这样子？考试 [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[11],"tags":[20],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/696"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=696"}],"version-history":[{"count":6,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/696\/revisions"}],"predecessor-version":[{"id":703,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/696\/revisions\/703"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=696"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=696"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=696"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre></code></pre></a></code></pre></code></pre></code></pre>
</div>