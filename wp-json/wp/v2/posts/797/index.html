{"id":797,"date":"2023-11-03T13:19:29","date_gmt":"2023-11-03T05:19:29","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=797"},"modified":"2023-11-03T13:19:29","modified_gmt":"2023-11-03T05:19:29","slug":"%e6%b5%85%e8%b0%88%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/11\/03\/%e6%b5%85%e8%b0%88%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f\/","title":{"rendered":"浅谈双连通分量"},"content":{"rendered":"<h1>前置知识\n<ul>\n<li><a href="\"https:\/\/oi-wiki.org\/graph\/concept\/\"">图论相关概念\n<li><a href="\"https:\/\/oi-wiki.org\/graph\/cut\/\"">割点和桥\n<li><a href="\"https:\/\/oi-wiki.org\/graph\/scc\/\"">强连通分量\n\n<h1>点双连通分量\n</h1>
<p>在一个无向图中，若删除图中的任意一个点，这个图还能连通，则称这个图为<strong>点双连通\n<p>例题：<a href="\"https:\/\/www.luogu.com.cn\/problem\/P8435\"">P8435 【模板】点双连通分量\n<p>在书写代码的时候有需要注意的地方会在程序中标注。\n
<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt; \nusing namespace std;\nconst int maxn = 5e5 + 5;\n\nint n, m;\nvector&lt;int&gt; G[maxn], ans[maxn];\nint dfn[maxn], low[maxn], cnt;\nint top, stk[2000005];\n\nvoid dfs(int x, int fa) {\n    dfn[x] = low[x] = ++dfn[0];\n    stk[++top] = x;\n    int son = 0;\n    for(auto to : G[x]) {\n        if(!dfn[to]) {\n            if(to == fa) continue;\n            son++;\n            dfs(to, x);\n            low[x] = min(low[x], low[to]);                                  \/\/注意dfn和low数组有没有搞混 \n            if(low[to] &gt;= dfn[x]) {                      \n                cnt++;\n                int tmp = 0;\n                while(stk[top + 1] != to) ans[cnt].push_back(stk[top--]);\n                ans[cnt].push_back(x);\n            }\n\n        }\n        else if(to != fa)low[x] = min(low[x],dfn[to]);\n    }\n    if(son == 0 &amp;&amp; fa == 0) ans[++cnt].push_back(x);                        \/\/不要忘记判读顶点 \n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\/\/  freopen(&quot;AKIOI.in&quot;, &quot;r&quot;, stdin);\n\/\/  freopen(&quot;AKIOI.out&quot;, &quot;w&quot;, stdout);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1, u, v; i &lt;= m; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    for(int i = 1; i &lt;= n; i++) {\n        if(dfn[i] != 0) continue;\n        top = 0;                    \/\/不要忘记清空栈 \n        dfs(i, 0);\n    }\n    cout &lt;&lt; cnt &lt;&lt; &#039;\\n&#039;;\n    for(int i = 1; i &lt;= cnt; i++) {\n        cout &lt;&lt; ans[i].size() &lt;&lt; &quot; &quot;;\n        for(auto j : ans[i]) cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n    return 0;\n\n}\n<h1>边双连通分量\n</h1>
<p>在一个无向图中，若删除图中的任意一条边，这个图还能连通，则称这个图为<strong>点双连通\n<p>例题：<a href="\"https:\/\/www.luogu.com.cn\/problem\/P8436\"">P8436 【模板】边双连通分量\n<p>在书写代码的时候有需要注意的地方会在程序中标注。\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int maxn = 5e5 + 5;\n\nint n, m, cnt = 0;\nvector&lt;pair&lt;int, int&gt; &gt; G[maxn];\nvector&lt;int&gt; ans[maxn];\nint dfn[maxn], low[maxn];\nstack&lt;int&gt; stk;\n\nvoid tarjan(int x, int fa) {\n    low[x] = dfn[x] = ++dfn[0];\n        stk.push(x);\n    for(auto i : G[x]) {\n        int to = i.first, it = i.second;    \n        if (it == (fa ^ 1)) continue;           \/\/利用位运算判断重边 \n        if(!dfn[to]) {\n            tarjan(to, it);\n            low[x] = min(low[x], low[to]);      \/\/dfn和low不要搞错 \n        }\n        else low[x] = min(low[x], dfn[to]);\n    }\n    if(dfn[x] == low[x]) {\n        cnt++;\n        ans[cnt].push_back(x);\n        while(!stk.empty() &amp;&amp; stk.top() != x) {ans[cnt].push_back(stk.top()), stk.pop();}   \/\/出栈的操作需要注意 \n        stk.pop();\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    \/\/ freopen(&quot;AKIOI.in&quot;, &quot;r&quot;, stdin);\n    \/\/ freopen(&quot;AKIOI.out&quot;, &quot;w&quot;, stdout);\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1, u, v; i &lt;= m; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(make_pair(v, i * 2));        \/\/给每条边编号方便去重 \n        G[v].push_back(make_pair(u, i * 2 + 1));\n    }\n    for(int i = 1; i &lt;= n; i++) {\n        if(!dfn[i]) tarjan(i, 0);\n    }\n    cout &lt;&lt; cnt &lt;&lt; &quot;\\n&quot;;\n    for(int i = 1; i &lt;= cnt; i++) {\n        cout &lt;&lt; ans[i].size() &lt;&lt; &quot; &quot;;\n        for(auto j : ans[i]) cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n\n    return 0;\n}\n","protected":false},"excerpt":{"rendered":"<p>前置知识 图论相关概念 割点和桥 强连通分量 点双连通分量 在一个无向图中，若删除图中的任意一个点，这个图还能 [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[27,28],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/797"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=797"}],"version-history":[{"count":1,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/797\/revisions"}],"predecessor-version":[{"id":798,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/797\/revisions\/798"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=797"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=797"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=797"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre></a></strong></code></pre></a></strong></a></li></a></li></a></li>
</ul>
</h1>