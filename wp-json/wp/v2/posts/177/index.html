{"id":177,"date":"2023-08-14T12:28:17","date_gmt":"2023-08-14T04:28:17","guid":{"rendered":"http:\/\/puhongyi.net:81\/?p=177"},"modified":"2023-08-14T12:28:17","modified_gmt":"2023-08-14T04:28:17","slug":"%e6%91%b8%e5%ba%95%e8%80%83%e8%af%95%e6%80%bb%e7%bb%93","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/08\/14\/%e6%91%b8%e5%ba%95%e8%80%83%e8%af%95%e6%80%bb%e7%bb%93\/","title":{"rendered":"摸底考试总结"},"content":{"rendered":"<h1>摸底考试总结\n<h2>总体评价\n</h2>
</h1>
<p>No luck &amp; No fun<br>\n整个比赛代码实现并不复杂，重在思维，考察基础知识的灵活运用\n
<h2>T1 100pts\n</h2>
<p>找规律，发现是单调底线序列接上单调递增序列就符合题意\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint T, n;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; T;\n    while(T--) {\n        cin &gt;&gt; n;\n        vector&lt;int&gt; a(n);\n        for(auto &amp;i : a) cin &gt;&gt; i;\n        bool tag = true, ans = true;\n        int it = 0;\n        while(a[it] &gt; a[it + 1]) it++;\n        while(a[it] &lt; a[it + 1]) it++;\n        if(it &gt;= n - 1) cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#039;\\n&#039;;\n        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#039;\\n&#039;;\n    }\n    return 0;\n}\n<h2>T2 60pts\n</h2>
<p>考场上想了半个小时没有想出来，最终打暴力得了60pts。<br>\n正解应该是双向链表，考试时没有想出来，以为是线段树打了个线段树结果还写挂了。\n
<pre><code class='\"language-cpp\"'>\/\/暴力\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\nusing namespace std;\nint n, q;\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; q;\n    vector&lt;int&gt; vec;\n    for(int i = 1; i &lt;= n; i++) {\n        int tmp;\n        cin &gt;&gt; tmp;\n        vec.push_back(tmp);\n    }\n    for(int i = 1, x, y; i &lt;= q; i++) {\n        cin &gt;&gt; x &gt;&gt; y;\n        int posx, posy;\n        for(int i = 0; i &lt; n; i++) {\n            if(vec[i] == x) posx = i;\n            if(vec[i] == y) {\n                posy = i;\n                break;\n            }\n        }\n        queue &lt;int&gt; Tmp;\n        for(auto i = vec.begin() + posx; i != vec.begin() + posy + 1; i++) {\n            Tmp.push(*i);\n        }\n        vec.erase(vec.begin() + posx, vec.begin() + posy + 1);\n        while(!Tmp.empty()) {\n            vec.push_back(Tmp.front());\n            Tmp.pop();\n        }\n    }\n    for(int i = n - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;;\n    }\n}\n<h2>T3 70pts\n</h2>
<p>这道题是我考场上想的最久的一道题，结果还是没有想出正解，打了暴力得了70pts，本来以为[latex]F(n)[\/latex]中的 [latex][latex][\/latex][\/latex]大于三十的情况除了二的次方外其他的数会非常小，但是发现自己还是错了。<br>\n整洁应该是通过逆向思维进行DFS\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    int ans = 0;\n    int S = min(n, (long long)10000000);\n\n    for (int i = 1; i &lt;= S; i++) {\n        int x = i, sum = 0;\n        while (x != 1) {\n            sum++;\n            x = x % 2 == 0 ?(x &gt;&gt; 1): x * 3 + 1;\n            if (sum &gt; k) {\n                ans++;\n                break;\n        }\n        }\n\n    }\n\n    int x = 1 &lt;&lt; 23, sum = 0, p = 23;\n    while (x &lt;= n &amp;&amp; p &lt;= k) {\n        sum++;\n        x *= 2;\n        p++;\n    }\n\n    ans += max((n &gt;= 10000000 ? n - 10000000 : 0) - sum, 0LL);\n    cout &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n}\n<h2>T4 49pts\n</h2>
<p>这道题就是前不久我学的KMP字符串匹配算法，但是因为在T3上花了过多的时间，导致后面非常的慌张，没有心思细想，导致这种几乎是板子的KMP也没有想出来。<br>\n于是我直接<code>不可以总司令骗了49分\n<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;random&gt;\n#include &lt;time.h&gt;\nusing namespace std;\n\nint main() {\n    srand(int(time(0)));\n    if(rand() % 2) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;\n    else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;\n}\n<h2>T5 25pts\n</h2>
<p>这道题考试时因为没有时间想，搜索暴力都没有来得及打，依然是<code>不可以总司令骗了25分。<br>\n正解应该是贪心。\n<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; -1 &lt;&lt; endl;\n}\n<h2>T6 50pts\n</h2>
<p>这道题稍微看了一会，通过分析样例发现了一些规律，提交后得了50分<br>\n正解应该是得到结论：<strong>若一个连通块内边数的奇偶性与点的奇偶性相同则总能找到一个方案使得偶点变为0，若不相同则为1\n<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;random&gt;\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    cout &lt;&lt; min(m, n) &lt;&lt; endl;\n\n}\n<h2>总结\n</h2>
<p>· 这次考试的时间安排还是挺不合理的\n
<p>· 拥有武器却瞄不准，思维僵化\n","protected":false},"excerpt":{"rendered":"
<p>摸底考试总结 总体评价 No luck &amp; No fun 整个比赛代码实现并不复杂，重在思维，考察基础 [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12,11],"tags":[],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/177"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=177"}],"version-history":[{"count":1,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/177\/revisions"}],"predecessor-version":[{"id":178,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/177\/revisions\/178"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=177"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=177"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=177"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre></strong></code></pre></code></code></pre></code></code></pre></code></pre></code></pre>