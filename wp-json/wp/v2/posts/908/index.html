{"id":908,"date":"2023-11-15T18:53:25","date_gmt":"2023-11-15T10:53:25","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=908"},"modified":"2023-11-15T18:53:25","modified_gmt":"2023-11-15T10:53:25","slug":"csp-s-2023-%e4%bb%a3%e7%a0%81","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/11\/15\/csp-s-2023-%e4%bb%a3%e7%a0%81\/","title":{"rendered":"CSP-S 2023 代码"},"content":{"rendered":"<h1>T1 密码锁\n<pre><code class='\"language-cpp\"'>\/\/ CSP-S 2023 密码锁\n#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\nusing VI = vector&lt;int&gt;;\nint main() {\n#ifdef ONLINE_JUDGE\n  freopen(&quot;lock.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;lock.out&quot;, &quot;w&quot;, stdout);\n#endif\n  int n;\n  cin &gt;&gt; n;\n  set&lt;VI&gt; AS;      \/\/ 输入的n种状态\n  map&lt;VI, int&gt; M;  \/\/ 可能的一些来源状态\n  VI A(5), B;\n  for (int i = 0; i &lt; n; i++) {\n    for (int&amp; a : A) cin &gt;&gt; a;\n    AS.insert(A);\n    for (int i = 0; i &lt; 5; i++)       \/\/ 转动的起点\n      for (int k = 1; k &lt;= 9; k++) {  \/\/ 转动的幅度\n        B = A;\n        (B[i] += k) %= 10, M[B]++;                     \/\/ [i,i] += k\n        if (i + 1 &lt; 5) (B[i + 1] += k) %= 10, M[B]++;  \/\/ [i,i+1] += k;\n      }\n  }\n  int ans = 0;\n  for (auto p : M) ans += (!AS.count(p.first) and p.second == n);\n  return printf(&quot;%d\\n&quot;, ans), 0;\n}\n\/\/ AC 100\n<h1>T2 消消乐\n<h2>90分代码\n<pre><code class='\"language-cpp\"'>\/\/ CSP-S 2023 密码锁\n#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\nusing LL = long long;\nint main() {\n#ifdef ONLINE_JUDGE\n  freopen(&quot;game.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;game.out&quot;, &quot;w&quot;, stdout);\n#endif\n  int n;\n  string A;\n  cin &gt;&gt; n &gt;&gt; A;\n  string stk;\n  unordered_map&lt;string, int&gt; SM{{stk, 1}};\n  LL ans = 0;\n  for (char c : A) {\n    if (!stk.empty() and stk.back() == c)\n      stk.pop_back();\n    else\n      stk += c;\n    ans += SM[stk], SM[stk]++;\n  }\n  return printf(&quot;%lld\\n&quot;, ans), 0;\n}\n\/\/ AC 90\n<h2>100分代码\n<pre><code class='\"language-cpp\"'>\/\/ CSP-S 2023 消消乐\n#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\nusing LL = long long;\nint main() {\n#ifdef ONLINE_JUDGE\n  freopen(&quot;game.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;game.out&quot;, &quot;w&quot;, stdout);\n#endif\n  int n;\n  string A;\n  cin &gt;&gt; n &gt;&gt; A;\n  string stk;\n  using ULL = unsigned long long;\n  vector&lt;ULL&gt; R(n + 1);\n  ULL P = 1e9 + 7;\n  R[0] = 1;\n  for (int i = 1; i &lt;= n; i++) R[i] = R[i - 1] * P;  \/\/ Pⁱ\n  unordered_map&lt;ULL, int&gt; HM{{0, 1}};  \/\/ 所有前缀消除之后的hash\n  LL ans = 0, h = 0;\n  for (char c : A) {\n    if (!stk.empty() and stk.back() == c)      \/\/ 栈顶可以消除\n      stk.pop_back(), h -= c * R[stk.size()];  \/\/ 消除并更新hash\n    else\n      h += c * R[stk.size()], stk += c;  \/\/ 入栈并更新hash\n    ans += HM[h], HM[h]++;  \/\/ 更新区间个数，记录栈的状态\n  }\n  return printf(&quot;%lld\\n&quot;, ans), 0;\n}\n\/\/ AC 100\n<h1>T3 结构体\n<pre><code class='\"language-cpp\"'>\/\/ CSP-S 2023 结构体\n#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\nusing LL = long long;\nstruct STInfo;\n\/\/ 基础类型及其长度\nmap&lt;string, int&gt; MT{{&quot;byte&quot;, 1}, {&quot;short&quot;, 2}, {&quot;int&quot;, 4}, {&quot;long&quot;, 8}};\nvector&lt;STInfo&gt; Ts;        \/\/ 所有的类型\nmap&lt;string, int&gt; TIDs;    \/\/ 类型名:id\nstruct STInfo {           \/\/ 结构体信息\n  string name;            \/\/ 类型名\n  LL align, size;         \/\/ 对齐要求, 大小\n  vector&lt;int&gt; mTypes;     \/\/ 成员类型\n  vector&lt;string&gt; mNames;  \/\/ 成员名称\n  map&lt;string, int&gt; mId;   \/\/ 成员名称:编号\n  vector&lt;LL&gt; m_st, m_ed;  \/\/ 每个成员占用内存的起始和结束地址\n  STInfo() : align(0), size(0) {}\n  void add_var(const string&amp; t, const string&amp; n) {  \/\/ 增加一个类型为t的成员n\n    assert(TIDs.count(t));     \/\/ 类型t必须已经存在\n    int ti = TIDs[t];\n    auto&amp; mt = Ts[ti];\n    align = max(align, mt.align);  \/\/ 对齐要求等于其成员的对齐要求的最大值\n    mId[n] = mNames.size();    \/\/ 成员名称对应的编号\n    mNames.push_back(n), mTypes.push_back(ti);  \/\/ 成员名称类型\n    LL st = m_ed.empty() ? 0 : m_ed.back();     \/\/ 新变量的起点\n    while (st % mt.align) ++st;   \/\/ 起点要考虑对齐\n    LL ed = st + mt.size;   \/\/ 终点不用考虑对齐\n    m_st.push_back(st), m_ed.push_back(ed), size = ed;\n    while (size % align) ++size;  \/\/ 整体大小考虑对齐\n  }\n  LL mem_addr(const string&amp; m) const {  \/\/ 成员m的地址\n    return m_st.at(mId.at(m));\n  }\n  int mem_type(const string&amp; m) const {  \/\/ 成员m的类型\n    return mTypes.at(mId.at(m));\n  }\n  int mid_of_addr(LL a) const {\n    assert(a &gt;= 0);\n    int msz = m_st.size();  \/\/ 看看哪个成员包含了这个地址, 数据量不大\n    for (int i = 0; i &lt; msz; ++i)\n      if (m_st[i] &lt;= a &amp;&amp; a &lt; m_ed[i]) return i;\n    return -1;\n  }\n};\nSTInfo G;    \/\/ 全局看做一个大结构体\nvoid init() {      \/\/ 基础类型初始化\n  for (auto p : MT) {  \/\/ byte，short，int，long\n    string s = p.first;\n    \/\/ 对于基本类型：对齐要求等于其占据空间大小, 并且没有成员\n    STInfo si;\n    si.name = s, si.align = MT[s], si.size = MT[s];\n    si.m_st.push_back(0), si.m_ed.push_back(MT[s]);\n    TIDs[s] = Ts.size(), Ts.push_back(si);\n  }\n  G.name = &quot;root&quot;;\n}\n\/\/ 读入并添加一个类型\nconst STInfo&amp; add_type() {\n  int k;\n  STInfo si;\n  cin &gt;&gt; si.name &gt;&gt; k;  \/\/ 示类型名与成员数量，\n  for (string t, n; k--;) cin &gt;&gt; t &gt;&gt; n, si.add_var(t, n);  \/\/ 添加成员\n  TIDs[si.name] = Ts.size(), Ts.push_back(si);\n  return Ts.back();\n}\n\/\/ 所有被定义的元素将按顺序，从内存地址为0开始依次排开\nLL def_var(const string&amp; type, const string&amp; name) {\n  return G.add_var(type, name), G.m_st.back();\n}\n\/\/ 如a.b.c，需要输出如上被访问的最内层元素的起始地址。\nLL find_addr(string v) {\n  replace(begin(v), end(v), &#039;.&#039;, &#039; &#039;);\n  stringstream ss(v);\n  vector&lt;string&gt; ns;\n  for (string s; ss &gt;&gt; s; ns.push_back(s))\n    ;\n  assert(!ns.empty());\n  LL a = G.mem_addr(ns[0]);  \/\/ 起始地址\n  for (int i = 1, ti = G.mem_type(ns[0]); i &lt; (int)ns.size(); i++) {\n    a += Ts[ti].mem_addr(ns[i]);  \/\/ 成员的内存中的起始位置(偏移量)\n    ti = Ts[ti].mem_type(ns[i]);  \/\/ 成员的类型, 进入下一级\n  }\n  return a;\n}\nstring addr_type_name(LL a) {  \/\/ 找到addr对应的变量类型\n  string s, er = &quot;ERR&quot;;\n  int mi = G.mid_of_addr(a);\n  if (mi == -1) return er;\n  s += G.mNames[mi], a -= G.m_st[mi];  \/\/ 进入下一级\n  for (int ti = G.mTypes[mi]; !MT.count(Ts[ti].name);) {\n    const auto&amp; tp = Ts[ti];\n    mi = tp.mid_of_addr(a);\n    if (mi == -1) return er;\n    s += &#039;.&#039; + tp.mNames[mi], a -= tp.m_st[mi], ti = tp.mTypes[mi];\n  }\n  return s;\n}\nint main() {\n#ifdef ONLINE_JUDGE\n  freopen(&quot;struct.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;struct.out&quot;, &quot;w&quot;, stdout);\n#endif\n  init();\n  int T;\n  cin &gt;&gt; T;\n  string t, n, s;\n  LL addr;\n  for (int i = 0, op; i &lt; T; i++) {\n    cin &gt;&gt; op;\n    if (op == 1) {\n      const STInfo&amp; tp = add_type();\n      printf(&quot;%lld %lld\\n&quot;, tp.size, tp.align);\n    } else if (op == 2)  \/\/ 该元素的类型与名称\n      cin &gt;&gt; t &gt;&gt; n, printf(&quot;%lld\\n&quot;, def_var(t, n));\n    else if (op == 3)\n      cin &gt;&gt; s, printf(&quot;%lld\\n&quot;, find_addr(s));\n    else if (op == 4)\n    cin &gt;&gt; addr, puts(addr_type_name(addr).c_str());\n  }\n  return 0;\n}\n\/\/ AC 100\n<h1>T4 种树\n<pre><code class='\"language-cpp\"'>\/\/ CSPS-2023 种树\n#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\nusing LL = long long;\nconst int NN = 1e5 + 4;\nLL A[NN], B[NN], C[NN];\nint N, F[NN];  \/\/ F[i] 表示i这个点最晚种树的天数\nvector&lt;int&gt; G[NN];\nvoid dfs(int u, int fa) {\n  for (auto v : G[u])  \/\/ v一定比父亲u晚一天种\n    if (v != fa) dfs(v, u), F[u] = min(F[u], F[v] - 1);\n}\nusing BI = __int128;\n\/\/ 要求点i在t天后达到目标(≥aᵢ)，必须在第f天前开始种，返回f\nLL solve_f(int i, const LL t) {\n  LL x = 4e18, b = B[i], c = C[i];  \/\/ x树的高度的拐点\n  if (c &lt; 0) x = (b - 1 - c - 1) \/ -c - 1;  \/\/ 一开始递减, 第x+1天开始增长率=1\n  LL l = 1, r = min(2LL * N, t) + 1;\n  while (l + 1 &lt; r) {\n    LL m = (l + r) \/ 2;\n    BI s = 0;   \/\/ x是拐点\n    if (x &gt; t)  \/\/ 直接计算从1到t(梯形面积)\n      s = (BI)(b + c * m + b + c * t) * (t - m + 1) \/ 2;\n    else if (x &gt;= m)  \/\/ m到x, x+1到t两段, 梯形+矩形的面积\n      s = (BI)(b + c * m + b + c * x) * (x - m + 1) \/ 2 + t - x;\n    else  \/\/ x &lt; m, 所以m到t一路增长率都是1\n      s = t - m + 1;\n    (s &lt; A[i] ? r : l) = m;\n  }\n  return r;\n}\nbool check(LL t) {\n  for (int i = 1; i &lt;= N; i++) {\n    LL f = solve_f(i, t);\n    if (f == 1) return false;\n    F[i] = f - 1;\n  }\n  dfs(1, 0);  \/\/ 父亲u还要考虑儿子v的种植时间要求(可能更早)\n  sort(F + 1, F + N + 1);  \/\/ 按照最晚种植的要求从低到高排序\n  for (int i = 1; i &lt;= N; i++)\n    if (F[i] &lt; i) return false;  \/\/ 无法满足要求\n  return true;\n}\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin &gt;&gt; N;\n  for (int i = 1; i &lt;= N; i++) cin &gt;&gt; A[i] &gt;&gt; B[i] &gt;&gt; C[i];\n  for (int i = 1, u, v; i &lt; N; i++)\n    cin &gt;&gt; u &gt;&gt; v, G[u].push_back(v), G[v].push_back(u);\n  int l = N, r = 1e9;  \/\/ 保证r一直是合法解\n  while (l + 1 &lt; r) {\n    int m = (l + r) \/ 2;\n    (check(m) ? r : l) = m;\n  }\n  return printf(&quot;%d\\n&quot;, r), 0;\n}\n\/\/ AC 100\n","protected":false},"excerpt":{"rendered":"<p>T1 密码锁 \/\/ CSP-S 2023 密码锁 #include &lt;bits\/stdc++.h&gt; [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/908"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=908"}],"version-history":[{"count":1,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/908\/revisions"}],"predecessor-version":[{"id":909,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/908\/revisions\/909"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=908"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=908"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=908"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre>
</h1></code></pre>
</h1></code></pre>
</h2></code></pre>
</h2>
</h1></code></pre>
</h1>