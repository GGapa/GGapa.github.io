{"id":278,"date":"2023-08-19T21:52:56","date_gmt":"2023-08-19T13:52:56","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=278"},"modified":"2023-08-23T11:39:44","modified_gmt":"2023-08-23T03:39:44","slug":"%e3%80%90lgr-155-div-3%e3%80%91%e6%b4%9b%e8%b0%b7%e5%9f%ba%e7%a1%80%e8%b5%9b-3-%e3%80%8cnnoi%e3%80%8dround-2-%e8%b5%9b%e5%90%8e%e6%80%bb%e7%bb%93","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2023\/08\/19\/%e3%80%90lgr-155-div-3%e3%80%91%e6%b4%9b%e8%b0%b7%e5%9f%ba%e7%a1%80%e8%b5%9b-3-%e3%80%8cnnoi%e3%80%8dround-2-%e8%b5%9b%e5%90%8e%e6%80%bb%e7%bb%93\/","title":{"rendered":"【LGR-155-Div.3】洛谷基础赛 #3 &#038;「NnOI」Round 2 赛后总结"},"content":{"rendered":"<h1>前言\n</h1>
<p>这是蒟蒻 AK 的第一场考试！<br>\n让我们恭喜它！<br>\n
<div class="fancybox-wrapper lazyload-container-unload" data-fancybox="post-images" href="https:\/\/ggapa.github.io\/wp-content\/uploads\/2023\/08\/image-1692451233838.png">
<img class='\"lazyload' lazyload-style-1 src="\"data:image\/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"" decoding='\"async\"' data-original='\"https:\/\/ggapa.github.io\/wp-content\/uploads\/2023\/08\/image-1692451233838.png\"' alt='\"file\"'><br>\n<em>比赛id：<a href="\"https:\/\/www.luogu.com.cn\/contest\/124047#description\"">124047\n<h1>T1 100pts\n</h1>
<p>通过数学计算一下高度即可\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\nusing namespace std;\nconst int maxn = 1e5 + 5;\n\nint n, T;\nint v[maxn], t[maxn], high[maxn];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; T;\n    for(int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i] &gt;&gt; t[i];\n        high[i] = max(T - t[i], 0) * v[i];\n    }\n    int minHigh = -1, index;\n    for(int i = 1; i &lt;= n; i++) {\n        if(high[i] &gt; minHigh) {\n            minHigh = high[i];\n            index = i;\n        }\n    }\n    cout &lt;&lt; index &lt;&lt; endl;\n}\n<h1>T2 100pts\n</h1>
<p>通过分析题目可知：\n
<ul>\n<li>如果侦测到冰川第一次融化，输出最近一个还没有融化的冰川即可。\n</li>
<li>如果所有冰川均融化则无解\n</li>
<li>如果侦测到冰川不是第一次融化，为了使字典序最小输出 1 即可，前提是冰川 1 已经融化，否则无解。\n\n<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n#define F &quot;No solution&quot;\n\nint n, m;\nchar info[1000005];\nvector&lt;int&gt; ans;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    cin &gt;&gt; info;\n    int now = 1;\n    for(int i = 0; i &lt; m; i++) {\n        if(info[i] == &#039;N&#039;) {\n            ans.push_back(now++);\n        }\n        else {\n            if(now == 1) {\n                cout &lt;&lt; F &lt;&lt; endl;\n                return 0;\n            }\n            ans.push_back(1);\n        }\n    }\n    if(now &gt; n + 1) {\n        cout &lt;&lt; F &lt;&lt; endl;\n        return 0;\n    }\n    for(int i = 0; i &lt; ans.size(); i++)     {\n        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n<h1>T3 100pts\n</h1>
<p>用的 STL 做的，题目涉及到初中数学一次函数\n
<p>令 $y_1 = k_1x + b_1$，$y_2 = k_2x + b_2$\n
<p>如果两条直线仅有一个交点，则：\n
<ul>\n<li>$k_1 \\ne k_2$\n\n<p>若两条直线至少有一个焦点，则：\n
<ul>\n<li>$k_1 \\ne k_2 || (k_1 = k_2 \\&amp; b_1 = b_2)$\n\n<p>起初我本来想用一个二维 map 来记录每一个一次函数，但是我发现这样子进行操作<code>2或操作<code>3太慢了，会TLE\n<p>但是通过之前的推论我们知道了进行操作<code>2只需要知道 $k$ 就行了，所以说我们可以拿一个 map 出来存放 $k$ 相同的数量，需要询问的时候直接输出一 $次函数数量总和 - (斜率 = k的一次函数的数量)$\n<p>遇到删除就不行了，删除时与给定的一次函数相同的一次函数也会被删除掉，也就是说我们还是需要一个二维 map 来记录每一个一次函数，在删除的时候把除了重合所有斜率相同的一次函数删除即可。\n
<p>但是这样子还是 TLE 了，卡了一下数据范围就过了。\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint n;\nmap&lt;int, map&lt;int, int&gt; &gt; linesmall;\nmap&lt;int, int&gt; linebig;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n;\n    int sum = 0;\n    while(n--) {\n        int cz;\n        cin &gt;&gt; cz;\n        int k, b;\n        cin &gt;&gt; k &gt;&gt; b;\n        if(cz == 1) {\n            linesmall[k][b]++;\n            sum++;\n            linebig[k]++;\n        }\n        if(cz == 2) {\n            cout &lt;&lt; sum - linebig[k] &lt;&lt; &#039;\\n&#039;;\n        }\n        if(cz == 3) {\n            sum = linebig[k] - linesmall[k][b];\n            map&lt;int ,int&gt; tmp;\n            linesmall[k][b] = 0;\n            if(abs(k) &lt;= 50)tmp = linesmall[k];\/\/最后一个数据点貌似非常水，不需要这句话就可以 A. 但是有了会 TLE， 所以说就特判一下为了防止 Subtask 2 出错\n            linesmall.clear();\n            linebig.clear();\n            linebig[k] = sum;\n            linesmall[k] = tmp;\n            tmp.clear();\n        }\n    }\n    return 0;\n}\n<h1>T4 100pts\n</h1>
<p>这道题一开始不容易看懂，但通过推理我们知道 $S^k$ 就相当于把字符串 $S$ 翻 $k$ 倍。\n
<p>因为可以无限翻倍，所以说除了 $S$ 中不存在的数之外，最长公共子序列的长度就是 $T\\cup S$ 元素的数量\n
<p>而 $k$ 也很好求了。\n
<pre><code class='\"language-cpp\"'>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nconst int maxn = 1e6 + 5;\n\nint n, m, c1, c2, k = 1;\nint ans = 0;\nint a[maxn];\nbool used[maxn];\nvector&lt;int&gt; b(1);\nvector&lt;int&gt; index[maxn];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;\n    for(int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; a[i];\n        used[a[i]] = true;\n        index[a[i]].push_back(i);\n    }\n    int ans = 0;\n    for(int i = 1, tmp; i &lt;= m; i++) {\n        cin &gt;&gt; tmp;\n        if(used[tmp]) b.push_back(tmp);\n        ans += used[tmp];\n    }\n    int it = 0;\n    for(int i = 1; i &lt; b.size(); i++) {\n        bool suc = true;\n        while(suc){\n            suc = true;\n            for(int j = 0; j &lt; index[b[i]].size(); j++) {\n                if(index[b[i]][j] &gt; it) {\n                    it = index[b[i]][j];\n                    suc = false;\n                    break;\n                }\n            }\n            if(suc) {\n                k++;\n                it = 0;\n            }\n        }\n    }\n    cout &lt;&lt; c1 * ans &lt;&lt; &quot; &quot; &lt;&lt;c2 * k;\n    return 0;\n}\n<h1>总结\n<ul>\n<li>\n<p>考试需要有灵活的思维\n\n
</li>
<li>\n<p>调试代码的能力真的蒻爆了\n\n
</li>
<li>\n<p>下次考试不要再迟到了！！！\n\n\n","protected":false},"excerpt":{"rendered":"
<p>前言 这是蒟蒻 AK 的第一场考试！ 让我们恭喜它！ 比赛id：124047 T1 100pts 通过数学计算 [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12,11],"tags":[],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/278"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=278"}],"version-history":[{"count":8,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/278\/revisions"}],"predecessor-version":[{"id":287,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/278\/revisions\/287"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=278"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=278"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=278"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}
</li>
</ul>
</h1></code></pre></code></pre></code></code></code>
</li>
</ul>
</li>
</ul></code></pre>
</li>
</ul></code></pre></a></em>
</div>