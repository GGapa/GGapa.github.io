{"id":1028,"date":"2024-01-27T20:09:46","date_gmt":"2024-01-27T12:09:46","guid":{"rendered":"https:\/\/ggapa.github.io\/?p=1028"},"modified":"2024-02-04T14:17:56","modified_gmt":"2024-02-04T06:17:56","slug":"%e9%94%99%e9%a2%98%e6%9c%ac","status":"publish","type":"post","link":"https:\/\/ggapa.github.io\/2024\/01\/27\/%e9%94%99%e9%a2%98%e6%9c%ac\/","title":{"rendered":"错题本"},"content":{"rendered":"<h1>树链剖分\n<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 5;\n\nint n, m, r, mod;\nint a[N], aa[N],dep[N], size[N], top[N], hson[N], fa[N], dfn[N];\nint cnt;\n\nstruct tree {\n    int laz, sum;\n    int l, r;\n}t[N * 4];\nvector&lt;int&gt; G[N];\n\n#define ls (x &lt;&lt; 1)\n#define rs (x &lt;&lt; 1 | 1)\n\nvoid pushdown(int x) {      \/\/懒标记下传出错\n    if(!t[x].laz) return;    \n    t[ls].sum = (t[ls].sum + t[x].laz * (t[ls].r - t[ls].l + 1) % mod) % mod;\n    t[rs].sum = (t[rs].sum + t[x].laz * (t[rs].r - t[rs].l + 1) % mod) % mod;\n    t[ls].laz = (t[ls].laz + t[x].laz) % mod; t[rs].laz = (t[rs].laz + t[x].laz) % mod;\n    t[x].laz = 0;\n}\nvoid pushup(int x) {\n    t[x].sum = (t[ls].sum + t[rs].sum) % mod;\n}\n\nvoid bulid(int x, int l, int r) {\n    t[x].l = l; t[x].r = r;\n    if(l == r) {\n        t[x].sum = a[l] % mod;\n        return ;\n    }\n    int mid = (l + r) &gt;&gt; 1;\n    bulid(ls, l, mid);\n    bulid(rs, mid + 1, r);\n    pushup(x);\n}\n\nvoid modify(int x, int l, int r, int ch) {\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) {\n        t[x].laz = (t[x].laz + ch) % mod;\n        t[x].sum = (t[x].sum + ch * (t[x].r - t[x].l + 1) % mod) % mod;\n        return ;\n    }\n    pushdown(x);\n    int mid = (t[x].l + t[x].r) &gt;&gt; 1;\n    if(l &lt;= mid) modify(ls, l, r, ch);\n    if(r &gt; mid) modify(rs, l, r, ch);\n    pushup(x);\n}\n\nint qurey(int x, int l, int r) {\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) {\n        return t[x].sum;\n    }\n    pushdown(x);\n    int mid = (t[x].l + t[x].r) &gt;&gt; 1, tmp = 0;\n    if(l &lt;= mid) tmp = (tmp + qurey(ls, l, r)) % mod;\n    if(r &gt; mid) tmp = (tmp + qurey(rs, l, r)) % mod;\n    return tmp;\n}\n\n#undef ls\n#undef rs\n\nvoid dfs1(int x, int f) {\n    dep[x] = dep[f] + 1; size[x] = 1; fa[x] = f;\n    for(auto to : G[x] ) {\n        if(to == f) continue;\n        dfs1(to, x);\n        size[x] += size[to];\n        if(size[hson[x]] &lt; size[to]) hson[x] = to;\n    }\n}\n\nvoid dfs2(int x, int tp) {\n    dfn[x] = ++cnt;\n    a[cnt] = aa[x];\n    top[x] = tp;\n    if(!hson[x]) return;\n    dfs2(hson[x], tp);\n    for(auto to : G[x] ) {\n        if(to == fa[x] || to == hson[x]) continue;\n        dfs2(to, to);\n    }\n}\n\nvoid mrange(int x, int y, int ch) {\n    while(top[x] != top[y]) {\n        if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        modify(1, dfn[top[x]], dfn[x], ch);\n        x = fa[top[x]];\n    }\n    if(dep[x] &gt; dep[y]) swap(x, y);\n    modify(1, dfn[x], dfn[y], ch);\n}\n\nint qrange(int x, int y) {\n    int ans = 0;\n    while(top[x] != top[y])  {\n        if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);\n        ans = (ans + qurey(1, dfn[top[x]], dfn[x])) % mod;  \/\/参数带错\n        x = fa[top[x]];\n    }\n    if(dep[x] &gt; dep[y]) swap(x, y);\n    ans = (ans + qurey(1, dfn[x], dfn[y])) % mod; \n    return ans;\n}\n\nvoid mson(int x, int ch) {\n    modify(1, dfn[x], dfn[x] + size[x] - 1, ch);\n}\n\nint qson(int x) {\n   return qurey(1, dfn[x], dfn[x] + size[x] - 1) % mod;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; mod;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; aa[i];\n    for(int i = 1, u, v; i &lt; n; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs1(r, 0);\n    dfs2(r, r);\n    bulid(1, 1, n);\n    \/\/ for(int i = 1; i &lt;= n; i++) cout &lt;&lt; dfn[i] &lt;&lt; &#039;\\n&#039;;\n    while(m--) {\n        int op, x, y, z;\n        cin &gt;&gt; op;\n        if(op == 1) {\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n            mrange(x, y, z);\n        }\n        if(op == 2) {\n            cin &gt;&gt; x &gt;&gt; y;\n            cout &lt;&lt; qrange(x, y) % mod&lt;&lt; &#039;\\n&#039;;\n        }\n        if(op == 3) {\n            cin &gt;&gt; x &gt;&gt; z;\n            mson(x, z);\n        }\n        if(op == 4) {\n            cin &gt;&gt; x;\n\n            cout &lt;&lt; qson(x) % mod&lt;&lt; &#039;\\n&#039;;\n        }\n    }\n    return 0;\n}\n<h1>网络最大流\n<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\n#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)\n#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)\nusing namespace std;\ntypedef long long ll;\nconst int N = 200 + 5, M = 5000 + 5;\n#define int long long\n\nint n, m, s, t;\nint tot = 1, head[M], cur[M];\nint dep[M];\nll ans;\n\nstruct edge {\n    int v, nxt;\n    ll val;\n}e[M * 2];\n\nvoid add(int u, int v, ll w) {\n    e[++tot].v = v;\n    e[tot].val = w;\n    e[tot].nxt = head[u];\n    head[u] = tot;\n\n    e[++tot].v = u;\n    e[tot].val = 0;\n    e[tot].nxt = head[v];\n    head[v] = tot;\n}\n\nint bfs() {\n    queue&lt;int&gt; q;\n    memset(dep, 0, sizeof(dep));    \/\/数组没有清空，表现：死循环退不出去。\n    q.push(s);\n    dep[s] = 1;\n    cur[s] = head[s];\n    while(!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for(int i = head[u]; i; i = e[i].nxt) {\n            int v = e[i].v;\n            if(e[i].val &gt; 0 &amp;&amp; !dep[v]) {\n                q.push(v);\n                cur[v] = head[v];\n                dep[v] = dep[u] + 1;\n                if(v == t) return 1;\n            }\n        }\n    }\n    return dep[t];\n}\n\nint dfs(int u, ll sum) {\n    if(u == t || !sum) return sum;\n    ll k, res = 0;\n    for(int i = cur[u]; i &amp;&amp; sum; i = e[i].nxt) {\n        int v = e[i].v;\n        cur[u] = i; \/\/没有加弧优化TLE\n        if(e[i].val &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) {\n            k = dfs(v, min(sum, e[i].val));\n            if(k == 0) dep[v] = 0;\n            e[i].val -= k;\n            e[i^1].val += k;    \/\/val错写成v，表现：可能死循环，也可能有一些其他的问题，尚不确定。\n            res += k;\n            sum -= k;\n        }\n    }\n    return res;\n}\n\nsigned main()  {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    rep(i, 1, m) {\n        int u, v; ll w;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        add(u, v, w);\n    }\n    while(bfs()) {\n        ans +=  dfs(s, LLONG_MAX);\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n\n    return 0;\n}\n<h1>历史最值线段树\n<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\n#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)\n#define per(i ,a ,b) for(int i = (a); i &gt;= (b); i--)\n\nusing namespace std;\nconst int N = 5e5 + 5;\ntypedef long long ll;\n\nint n, m;\nint a[N];\n\nstruct tree{\n    ll sum; \n    int l, r, maxa, cnt, se, maxb;\n    int add1, add2, add3, add4;\n}t[N &lt;&lt; 4];\n\n#define ls x &lt;&lt; 1\n#define rs x &lt;&lt; 1 | 1\n\nvoid pushup(int x) {\n    t[x].sum = t[ls].sum + t[rs].sum;\n    t[x].maxa = max(t[ls].maxa, t[rs].maxa);\n        t[x].maxb = max(t[ls].maxb, t[rs].maxb);\n        if(t[ls].maxa == t[rs].maxa) {\n        t[x].cnt = t[ls].cnt + t[rs].cnt;\n        t[x].se = max(t[ls].se, t[rs].se);\n    }\n    if(t[ls].maxa &gt; t[rs].maxa)  {\n        t[x].cnt = t[ls].cnt;\n        t[x].se = max(t[ls].se, t[rs].maxa);\n    }\n    if(t[ls].maxa &lt; t[rs].maxa) {\n        t[x].cnt = t[rs].cnt;\n        t[x].se = max(t[ls].maxa, t[rs].se);\n    }\n}\n\nvoid apply(int x, int tag1, int tag2, int tag3, int tag4) {\n    t[x].sum += 1ll * tag1 * t[x].cnt + 1ll * tag2 * (t[x].r - t[x].l + 1 - t[x].cnt);\n    t[x].maxb = max(t[x].maxb, t[x].maxa + tag3);       \/\/在给maxb赋值的时候，将 = 写成 +=，表现：区间历史最大值莫名其妙很大。\n    t[x].maxa += tag1;\n    if(t[x].se != -2e9) t[x].se += tag2;\n    t[x].add3 = max(t[x].add3, t[x].add1 + tag3);\n    t[x].add4 = max(t[x].add4, t[x].add2 + tag4);\n    t[x].add1 += tag1; t[x].add2 += tag2;\n} \n\nvoid pushdown(int x) {\n\n    int mxn = max(t[ls].maxa, t[rs].maxa);\n    if(t[ls].maxa == mxn) \n        apply(ls, t[x].add1, t[x].add2, t[x].add3, t[x].add4);\n    else apply(ls, t[x].add2, t[x].add2, t[x].add4, t[x].add4);     \/\/else 的赋值错误，若不是最大值则应该赋非最大值的懒标记，表现：极少情况下（有可能是数据范围太小了）会偶尔冒出来一个错误的求和操作。\n    if(t[rs].maxa == mxn) \n        apply(rs, t[x].add1, t[x].add2, t[x].add3, t[x].add4);\n    else apply(rs, t[x].add2, t[x].add2, t[x].add4, t[x].add4);     \/\/ else 的赋值错误，若不是最大值则应该赋非最大值的懒标记，表现：极少情况下（有可能是数据范围太小了）会偶尔冒出来一个错误的求和操作。\n    t[x].add1 = t[x].add2 = t[x].add3 = t[x].add4 = 0; \n}\nvoid bulid(int x, int l, int r) {\n    t[x].l = l; t[x].r = r;\n    t[x].add1 = t[x].add2 = t[x].add3 = t[x].add4 = 0;\n    if(l == r) {\n        t[x].maxa =  t[x].maxb = t[x].sum = a[l];\n        t[x].se = -2e9; t[x].cnt = 1; \n        return ;\n    }\n    int mid = (l + r) &gt;&gt; 1;\n    bulid(ls, l, mid);\n    bulid(rs, mid + 1, r);\n    pushup(x);\n}\n\nvoid modify_add(int x, int l, int r, int v) {\n    if(t[x].r &lt; l || t[x].l &gt; r) return ;\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) {\n        apply(x, v, v, v, v);\n        return ;\n    }\n    pushdown(x);    \n    modify_add(ls, l, r, v); modify_add(rs, l, r, v);\n    pushup(x);\n}\n\nvoid modify_min(int x, int l, int r, int v) {\n    if(t[x].r &lt; l || t[x].l &gt; r || v &gt;= t[x].maxa) return ;     \/\/退出条件少写了，表现：把最小值改大了。\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r &amp;&amp; t[x].se &lt; v) {             \/\/条件少写了，表现：把最小值改大了。\n        int tmp = t[x].maxa - v;\n        \/\/ t[x].sum -= 1ll * t[x].cnt * tmp;\n        \/\/ t[x].maxa = v; t[x].add1 -= tmp;\n        apply(x, -tmp, 0, -tmp, 0);\n        \/\/ apply(x, v - t[x].maxa, 0, v - t[x].maxa, 0);\n        return ;\n    }\n    pushdown(x);\n    modify_min(ls, l, r, v); modify_min(rs, l, r, v);\n    pushup(x);\n}\n\nll query_sum(int x, int l, int r) {\n    if(t[x].r &lt; l || t[x].l &gt; r) return 0;\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) \n        return t[x].sum;\n    pushdown(x);\n    return query_sum(ls, l, r) + query_sum(rs, l, r);\n}\n\nint query_maxa(int x, int l, int r) {\n    if(t[x].r &lt; l || t[x].l &gt; r) return -2e9;   \/\/不小心 return 0，而不是返回-inf，表现：最大值输出0\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) \n        return t[x].maxa;\n    pushdown(x);\n    return max(query_maxa(ls, l, r), query_maxa(rs, l, r));\n}\n\nint query_maxb(int x, int l, int r) {\n    if(t[x].r &lt; l || t[x].l &gt; r) return -2e9;   \/\/不小心 return 0，而不是返回-inf，表现：最大值输出0\n    if(l &lt;= t[x].l &amp;&amp; t[x].r &lt;= r) \n        return t[x].maxb;\n    pushdown(x);\n    return max(query_maxb(ls, l, r),query_maxb(rs, l, r));\n}\n\n#undef ls\n#undef rs\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    rep(i, 1, n) cin &gt;&gt; a[i];\n    bulid(1, 1, n);\n    while(m--) {\n        int op, l, r, v;\n        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n        if(op == 1) {\n            cin &gt;&gt; v;\n            modify_add(1, l, r, v);\n        }\n        if(op == 2) {\n            cin &gt;&gt; v;\n            modify_min(1, l, r, v);\n        } \n        if(op == 3) cout &lt;&lt; query_sum(1, l, r) &lt;&lt; &#039;\\n&#039;;\n        if(op == 4) cout &lt;&lt; query_maxa(1, l, r) &lt;&lt; &#039;\\n&#039;;\n        if(op == 5) cout &lt;&lt; query_maxb(1, l, r) &lt;&lt; &#039;\\n&#039;;\n    }\n\n    return 0;\n}\n\n\/\/ P6242 【模板】线段树 3（区间最值操作、区间历史最值）\n\n<h1>主席树\n<pre><code class='\"language-cpp\"'>#include&lt;bits\/stdc++.h&gt;\nusing namespace std;\n#define int long long\nconst int maxn = 4e5 + 10, N = 2e5;\nint n, m, tot, a[maxn &lt;&lt; 5], b[maxn &lt;&lt; 5], rt[maxn &lt;&lt; 5];\nint siz;\nstruct node{\n    int ls, rs, sum;\n}t[maxn &lt;&lt; 5];\nvoid init(){\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i];\n    sort(b + 1, b + n + 1);\n    siz = unique(b + 1, b + n + 1) - b - 1;\n    for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(b + 1, b + siz + 1, a[i]) - b;\n}\ninline void modify(int&amp; id, int pre, int l, int r, int x){\n    id = ++tot;\n    t[id] = t[pre];\n    t[id].sum++;\n    if (l == r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    if (x &lt;= mid) modify(t[id].ls, t[pre].ls, l, mid, x);\n    else modify(t[id].rs, t[pre].rs, mid + 1, r, x);\n}\ninline int query(int id1, int id2, int l, int r, int k){\n    if (l == r) return l;\n    int mid = (l + r) &gt;&gt; 1;\n    int sum1 = t[t[id1].ls].sum - t[t[id2].ls].sum;\n    if (sum1 &gt;= k) return query(t[id1].ls, t[id2].ls, l, mid, k);\n    else return query(t[id1].rs, t[id2].rs, mid + 1, r, k - sum1);\n}\nvoid build_tree(){\n    for (int i = 1; i &lt;= n; i++){\n        modify(rt[i], rt[i - 1], 1, siz, a[i]);     \/\/ 警钟\n    }\n}\nvoid work(){\n    for (int i = 1; i &lt;= m; i++){\n        int l, r, k;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n        cout &lt;&lt; b[query(rt[r], rt[l - 1], 1, siz, k)] &lt;&lt; &#039;\\n&#039;;      \n    }\n}\nsigned main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    init();\n    build_tree();\n    work();\n    return 0;\n}\n<h1>最短路\n<h2>Floyd\n<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\n#define rep(i, a, b) for(int i = (a); i &lt;= (b); i++)\n#define per(i, a, b) for(int i = (a); i &gt;= (b); i--)\nusing namespace std;\ntypedef long long ll;\nconst int N = 500 + 5;\n#define int long long\n\nll a[N][N];\nint n, m, q;\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    rep(i, 1, n) rep(j, 1, n) a[i][j] = LLONG_MAX;\n    for(int i = 1, u, v, w; i &lt;= m; i++) {\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        a[u][v] = a[v][u] = min(a[u][v], w);    \/\/重边处理\n    }\n    rep(i, 1, n) a[i][i] = 0;               \/\/自己到自己\n    rep(k, 1, n) rep(i, 1, n) rep(j ,1 ,n)\n        if(a[i][k] != LLONG_MAX &amp;&amp; a[k][j] != LLONG_MAX &amp;&amp; i != k &amp;&amp; j != k)        \/\/ik, jk 不同 \n            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n    for(int i = 1, u, v; i &lt;= q; i++) {\n        cin &gt;&gt; u &gt;&gt; v;\n        cout &lt;&lt; (a[u][v] == LLONG_MAX ? -1 : a[u][v]) &lt;&lt; &#039;\\n&#039;;\n    }\n    return 0;\n}\n<h2>Dijkstra\n<pre><code class='\"language-cpp\"'>#include &lt;bits\/stdc++.h&gt;\n#define rep(i, a, b) for(int i = (a), stOwxc = (b); i &lt;= stOwxc; i++)\n#define per(i, a, b) for(int i = (a), stOwxc = (b); i &gt;= stOwxc; i--)\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef pair&lt;int, int&gt; pii;\nconst int N = 1e5 + 5;\n\nint n, m, s = 1;\nvector&lt;pii&gt; G[N];\nll dis[N];\nbool vis[N];\n\nvoid Dijkstra() {\n    for(int i = 1; i &lt;= n; i++) dis[i] = 1e18;\n    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;\n    dis[s] = 0; \n    q.push({0, s});\n\n    while(!q.empty()) {\n        int x = q.top().second; q.pop();\n        if(vis[x]) continue;            \/\/vis数组\n        vis[x] = true;\n        for(auto to : G[x] ){\n            if(dis[to.first] &gt; dis[x] + to.second) {\n                dis[to.first] = dis[x] + to.second;\n                if(!vis[to.first])\n                    q.push({dis[to.first], to.first});\n\n            }\n        }\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    for(int i = 1, u, v, w; i &lt;= m; i++) {\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        G[u].push_back({v, w});\n    }\n    Dijkstra();\n    rep(i, 1, n) cout &lt;&lt; dis[i] &lt;&lt; &quot; \\n&quot;[i == n];\n\n    return 0;\n}\n","protected":false},"excerpt":{"rendered":"<p>树链剖分 #include &lt;bits\/stdc++.h&gt; using namespace std [&hellip;]\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[12],"tags":[],"_links":{"self":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/1028"}],"collection":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/comments?post=1028"}],"version-history":[{"count":9,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/1028\/revisions"}],"predecessor-version":[{"id":1062,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/posts\/1028\/revisions\/1062"}],"wp:attachment":[{"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/media?parent=1028"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/categories?post=1028"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/ggapa.github.io\/wp-json\/wp\/v2\/tags?post=1028"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}</code></pre>
</h2></code></pre>
</h2>
</h1></code></pre>
</h1></code></pre>
</h1></code></pre>
</h1></code></pre>
</h1>